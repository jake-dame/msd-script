<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>msdscript: parse.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">msdscript
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">parse.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Parsing functions definitions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;iostream&gt;</code><br />
<code>#include &quot;<a class="el" href="parse_8h_source.html">parse.h</a>&quot;</code><br />
</div>
<p><a href="parse_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a02d3bcbac10ec6095b06d399a3cea013" id="r_a02d3bcbac10ec6095b06d399a3cea013"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02d3bcbac10ec6095b06d399a3cea013">parse_expr</a> (std::istream &amp;stream)</td></tr>
<tr class="memdesc:a02d3bcbac10ec6095b06d399a3cea013"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias function for maintainability.  <br /></td></tr>
<tr class="memitem:aa735224dfbda1ba968f2306e9ae83443" id="r_aa735224dfbda1ba968f2306e9ae83443"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa735224dfbda1ba968f2306e9ae83443">parse_eqs</a> (std::istream &amp;stream)</td></tr>
<tr class="memdesc:aa735224dfbda1ba968f2306e9ae83443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="class_eq.html" title="An Expr derived class representing an equality operation/comparison.">Eq</a> objects from parsed comparison expressions.  <br /></td></tr>
<tr class="memitem:a1235a8cadf74e43c7ee285a48dbfff7d" id="r_a1235a8cadf74e43c7ee285a48dbfff7d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1235a8cadf74e43c7ee285a48dbfff7d">parse_adds</a> (std::istream &amp;stream)</td></tr>
<tr class="memdesc:a1235a8cadf74e43c7ee285a48dbfff7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="class_add.html" title="An Expr derived class representing an addition operation.">Add</a> objects from parsed addition expressions.  <br /></td></tr>
<tr class="memitem:a25b93d81626f3b63ec9c8a1516c04624" id="r_a25b93d81626f3b63ec9c8a1516c04624"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25b93d81626f3b63ec9c8a1516c04624">parse_mults</a> (std::istream &amp;stream)</td></tr>
<tr class="memdesc:a25b93d81626f3b63ec9c8a1516c04624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="class_mult.html" title="An Expr derived class representing a multiplication operation.">Mult</a> objects from parsed multiplication expressions.  <br /></td></tr>
<tr class="memitem:aba92031976f5b73efe5cdf16e8605bc1" id="r_aba92031976f5b73efe5cdf16e8605bc1"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba92031976f5b73efe5cdf16e8605bc1">parse_calls</a> (std::istream &amp;stream)</td></tr>
<tr class="memitem:a24cb2604e1862c150f5661400ebe216c" id="r_a24cb2604e1862c150f5661400ebe216c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24cb2604e1862c150f5661400ebe216c">parse_bases</a> (std::istream &amp;stream)</td></tr>
<tr class="memdesc:a24cb2604e1862c150f5661400ebe216c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles unary and ternary expressions in various ways.  <br /></td></tr>
<tr class="memitem:a610c42a31bade3d9ac4e95f469537ba8" id="r_a610c42a31bade3d9ac4e95f469537ba8"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a610c42a31bade3d9ac4e95f469537ba8">parse_num</a> (std::istream &amp;stream)</td></tr>
<tr class="memdesc:a610c42a31bade3d9ac4e95f469537ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="class_num.html" title="An Expr derived class representing a basic integer.">Num</a> objects from parsed numerical expressions.  <br /></td></tr>
<tr class="memitem:a21d8176490dde47a2a7daf786342e10f" id="r_a21d8176490dde47a2a7daf786342e10f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21d8176490dde47a2a7daf786342e10f">parse_bool</a> (std::istream &amp;stream)</td></tr>
<tr class="memdesc:a21d8176490dde47a2a7daf786342e10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="class_bool.html" title="An Expr derived class representing a basic boolean value.">Bool</a> objects from parsed boolean expressions.  <br /></td></tr>
<tr class="memitem:aefd6876051de7f1849810adecbed114e" id="r_aefd6876051de7f1849810adecbed114e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefd6876051de7f1849810adecbed114e">parse_var</a> (std::istream &amp;stream)</td></tr>
<tr class="memdesc:aefd6876051de7f1849810adecbed114e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="class_var.html" title="An Expr derived class representing a string placeholder (variable)">Var</a> objects from parsed alphabetical expressions.  <br /></td></tr>
<tr class="memitem:a7c62fbb91c45c905dce913345fd4e76d" id="r_a7c62fbb91c45c905dce913345fd4e76d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c62fbb91c45c905dce913345fd4e76d">parse_let</a> (std::istream &amp;stream)</td></tr>
<tr class="memdesc:a7c62fbb91c45c905dce913345fd4e76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="class_let.html" title="An Expr derived class supporting let binding.">Let</a> objects from parsed let-binding expressions.  <br /></td></tr>
<tr class="memitem:a880b69bf83a248545e84132a9373e0bf" id="r_a880b69bf83a248545e84132a9373e0bf"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a880b69bf83a248545e84132a9373e0bf">parse_if</a> (std::istream &amp;stream)</td></tr>
<tr class="memdesc:a880b69bf83a248545e84132a9373e0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="class_if.html" title="An Expr derived class representing a conditional operation expression.">If</a> objects from parsed condition expressions (e.g. "_if ... _then ... _else ...")  <br /></td></tr>
<tr class="memitem:a6ae77f9b1749a85aed0842710b49920e" id="r_a6ae77f9b1749a85aed0842710b49920e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ae77f9b1749a85aed0842710b49920e">parse_fun</a> (std::istream &amp;stream)</td></tr>
<tr class="memitem:ae3f47f2a3de0566fabc8c5ea78c38c5a" id="r_ae3f47f2a3de0566fabc8c5ea78c38c5a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3f47f2a3de0566fabc8c5ea78c38c5a">parse_paren</a> (std::istream &amp;stream)</td></tr>
<tr class="memdesc:ae3f47f2a3de0566fabc8c5ea78c38c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles parentheses and calls new recursive chain for nested expressions.  <br /></td></tr>
<tr class="memitem:a6e8ce61dc8d1637006008a1e844cea4c" id="r_a6e8ce61dc8d1637006008a1e844cea4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e8ce61dc8d1637006008a1e844cea4c">build_number</a> (std::istream &amp;stream)</td></tr>
<tr class="memdesc:a6e8ce61dc8d1637006008a1e844cea4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for <a class="el" href="#a610c42a31bade3d9ac4e95f469537ba8" title="Constructs Num objects from parsed numerical expressions.">parse_num()</a> that builds singular integers from multiple chars.  <br /></td></tr>
<tr class="memitem:acaf404de21e5bcf0a67503e561e7ab53" id="r_acaf404de21e5bcf0a67503e561e7ab53"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acaf404de21e5bcf0a67503e561e7ab53">peek_keyword</a> (std::istream &amp;stream)</td></tr>
<tr class="memdesc:acaf404de21e5bcf0a67503e561e7ab53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for parse_bases that handles elements of mathematical expressions that begin with an underscore.  <br /></td></tr>
<tr class="memitem:a6a3dbb3c272ab0413a979ea4b4782ce6" id="r_a6a3dbb3c272ab0413a979ea4b4782ce6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a3dbb3c272ab0413a979ea4b4782ce6">consume</a> (std::istream &amp;stream, const int expect)</td></tr>
<tr class="memdesc:a6a3dbb3c272ab0413a979ea4b4782ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that safely removes handled tokens from the stream.  <br /></td></tr>
<tr class="memitem:ab8c258ca9439db5f6ad2ff154f4b685f" id="r_ab8c258ca9439db5f6ad2ff154f4b685f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8c258ca9439db5f6ad2ff154f4b685f">consume</a> (std::istream &amp;stream, const std::string &amp;str)</td></tr>
<tr class="memdesc:ab8c258ca9439db5f6ad2ff154f4b685f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A polymorphic version of consume that accepts std::string inputs.  <br /></td></tr>
<tr class="memitem:a7dc400356690d7c98c8720e80f778ece" id="r_a7dc400356690d7c98c8720e80f778ece"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7dc400356690d7c98c8720e80f778ece">consume_whitespace</a> (std::istream &amp;stream)</td></tr>
<tr class="memdesc:a7dc400356690d7c98c8720e80f778ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for parsing that handles whitespace.  <br /></td></tr>
<tr class="memitem:abeda332110606e07a189e74807e06799" id="r_abeda332110606e07a189e74807e06799"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abeda332110606e07a189e74807e06799">parse_expr</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:abeda332110606e07a189e74807e06799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a mathematical expression (string) to an <a class="el" href="class_expr.html" title="An abstract, base class representing a mathematical expression.">Expr</a> object.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Parsing functions definitions. </p>

<p class="definition">Definition in file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a6e8ce61dc8d1637006008a1e844cea4c" name="a6e8ce61dc8d1637006008a1e844cea4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8ce61dc8d1637006008a1e844cea4c">&#9670;&#160;</a></span>build_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int build_number </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper for <a class="el" href="#a610c42a31bade3d9ac4e95f469537ba8" title="Constructs Num objects from parsed numerical expressions.">parse_num()</a> that builds singular integers from multiple chars. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A reference to an input stream to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="class_var.html" title="An Expr derived class representing a string placeholder (variable)">Var</a> object</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>On detecting malformed numbers </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00304">304</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a6a3dbb3c272ab0413a979ea4b4782ce6" name="a6a3dbb3c272ab0413a979ea4b4782ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3dbb3c272ab0413a979ea4b4782ce6">&#9670;&#160;</a></span>consume() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void consume </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>expect</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function that safely removes handled tokens from the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A reference to an input stream to read from </td></tr>
    <tr><td class="paramname">expect</td><td>The element expected to be in the stream's next position</td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="#a6a3dbb3c272ab0413a979ea4b4782ce6" title="Helper function that safely removes handled tokens from the stream.">consume()</a> function is the only place within the parsing chain where get() is called on the input stream. The safety mechanism provided by the second parameter ("expect") ensures that the element being removed from the stream is in alignment with what is expected to be removed. With complex recursive parsing using an input stream, this function provides an extra layer of security for the implementation and aids in checking for valid grammar in the user-inputted expression. It is essentially an aid to maintainability and debugging, and also improves readability.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>Throws if mismatch between char and expect </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00461">461</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="ab8c258ca9439db5f6ad2ff154f4b685f" name="ab8c258ca9439db5f6ad2ff154f4b685f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c258ca9439db5f6ad2ff154f4b685f">&#9670;&#160;</a></span>consume() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void consume </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A polymorphic version of consume that accepts std::string inputs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A reference to an input stream to read from </td></tr>
    <tr><td class="paramname">str</td><td>The string to consume</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="#a6a3dbb3c272ab0413a979ea4b4782ce6" title="Helper function that safely removes handled tokens from the stream.">consume()</a> description of functionality</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>Throws if mismatch between any char and expect </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00478">478</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a7dc400356690d7c98c8720e80f778ece" name="a7dc400356690d7c98c8720e80f778ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc400356690d7c98c8720e80f778ece">&#9670;&#160;</a></span>consume_whitespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void consume_whitespace </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper for parsing that handles whitespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A reference to an input stream to read from </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00492">492</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a1235a8cadf74e43c7ee285a48dbfff7d" name="a1235a8cadf74e43c7ee285a48dbfff7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1235a8cadf74e43c7ee285a48dbfff7d">&#9670;&#160;</a></span>parse_adds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt; parse_adds </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs <a class="el" href="class_add.html" title="An Expr derived class representing an addition operation.">Add</a> objects from parsed addition expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A reference to an input stream to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="class_bool.html" title="An Expr derived class representing a basic boolean value.">Bool</a> object </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00128">128</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a24cb2604e1862c150f5661400ebe216c" name="a24cb2604e1862c150f5661400ebe216c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24cb2604e1862c150f5661400ebe216c">&#9670;&#160;</a></span>parse_bases()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt; parse_bases </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles unary and ternary expressions in various ways. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A reference to an input stream to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an <a class="el" href="class_expr.html" title="An abstract, base class representing a mathematical expression.">Expr</a> object</dd></dl>
<p>Calls base-case helper functions: <a class="el" href="#a610c42a31bade3d9ac4e95f469537ba8" title="Constructs Num objects from parsed numerical expressions.">parse_num()</a>, <a class="el" href="#aefd6876051de7f1849810adecbed114e" title="Constructs Var objects from parsed alphabetical expressions.">parse_var()</a>, or <a class="el" href="#a7c62fbb91c45c905dce913345fd4e76d" title="Constructs Let objects from parsed let-binding expressions.">parse_let()</a>. Returns to <a class="el" href="#a25b93d81626f3b63ec9c8a1516c04624" title="Constructs Mult objects from parsed multiplication expressions.">parse_mults()</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>On encountering characters not valid in any unary, binary, or ternary expression </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00183">183</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a21d8176490dde47a2a7daf786342e10f" name="a21d8176490dde47a2a7daf786342e10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d8176490dde47a2a7daf786342e10f">&#9670;&#160;</a></span>parse_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt; parse_bool </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs <a class="el" href="class_bool.html" title="An Expr derived class representing a basic boolean value.">Bool</a> objects from parsed boolean expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A reference to an input stream to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="class_bool.html" title="An Expr derived class representing a basic boolean value.">Bool</a> object </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00255">255</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="aba92031976f5b73efe5cdf16e8605bc1" name="aba92031976f5b73efe5cdf16e8605bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba92031976f5b73efe5cdf16e8605bc1">&#9670;&#160;</a></span>parse_calls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt; parse_calls </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00157">157</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="aa735224dfbda1ba968f2306e9ae83443" name="aa735224dfbda1ba968f2306e9ae83443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa735224dfbda1ba968f2306e9ae83443">&#9670;&#160;</a></span>parse_eqs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt; parse_eqs </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs <a class="el" href="class_eq.html" title="An Expr derived class representing an equality operation/comparison.">Eq</a> objects from parsed comparison expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A reference to an input stream to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an <a class="el" href="class_eq.html" title="An Expr derived class representing an equality operation/comparison.">Eq</a> object </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00102">102</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="abeda332110606e07a189e74807e06799" name="abeda332110606e07a189e74807e06799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeda332110606e07a189e74807e06799">&#9670;&#160;</a></span>parse_expr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt; parse_expr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a mathematical expression (string) to an <a class="el" href="class_expr.html" title="An abstract, base class representing a mathematical expression.">Expr</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to parse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="class_expr.html" title="An abstract, base class representing a mathematical expression.">Expr</a> object representing a mathematical expression (string)</dd></dl>
<p>The <a class="el" href="#a02d3bcbac10ec6095b06d399a3cea013" title="An alias function for maintainability.">parse_expr()</a> function is the entry point for the recursion chain that recursively parses a mathematical expression (string). The recursion follows parses binary expressions, then uses a sort of dispatching function to handle unary and ternary expressions; it is depicted below: </p><pre class="fragment"> parse_expr() --&gt;  parse_eqs() --&gt;   parse_adds() --&gt;

 parse_mults() --&gt; parse_calls() --&gt; parse_bases()
</pre><p><a class="el" href="#a24cb2604e1862c150f5661400ebe216c" title="Handles unary and ternary expressions in various ways.">parse_bases()</a> employs a number of helper functions that further parse the appropriate expressions. Other helpers that aid in parsing fall in the general category, and aid in reading from the input stream safely, removing whitespace, etc.</p>
<p><a class="el" href="class_if.html" title="An Expr derived class representing a conditional operation expression.">If</a> the recursion chain has returned to this function and there are still characters in the stream, they were not detected within the recursion chain, meaning they are not valid.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>On encountering invalid input that was categorically passed over elsewhere in the recursion chain </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00074">74</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a02d3bcbac10ec6095b06d399a3cea013" name="a02d3bcbac10ec6095b06d399a3cea013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d3bcbac10ec6095b06d399a3cea013">&#9670;&#160;</a></span>parse_expr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt; parse_expr </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alias function for maintainability. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A reference to an input stream to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an <a class="el" href="class_expr.html" title="An abstract, base class representing a mathematical expression.">Expr</a> object </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00092">92</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a6ae77f9b1749a85aed0842710b49920e" name="a6ae77f9b1749a85aed0842710b49920e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae77f9b1749a85aed0842710b49920e">&#9670;&#160;</a></span>parse_fun()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt; parse_fun </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00404">404</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a880b69bf83a248545e84132a9373e0bf" name="a880b69bf83a248545e84132a9373e0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880b69bf83a248545e84132a9373e0bf">&#9670;&#160;</a></span>parse_if()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt; parse_if </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs <a class="el" href="class_if.html" title="An Expr derived class representing a conditional operation expression.">If</a> objects from parsed condition expressions (e.g. "_if ... _then ... _else ...") </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A reference to an input stream to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an <a class="el" href="class_if.html" title="An Expr derived class representing a conditional operation expression.">If</a> object </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00391">391</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a7c62fbb91c45c905dce913345fd4e76d" name="a7c62fbb91c45c905dce913345fd4e76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c62fbb91c45c905dce913345fd4e76d">&#9670;&#160;</a></span>parse_let()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt; parse_let </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs <a class="el" href="class_let.html" title="An Expr derived class supporting let binding.">Let</a> objects from parsed let-binding expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A reference to an input stream to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="class_let.html" title="An Expr derived class supporting let binding.">Let</a> object</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>On invalid let bindings </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00362">362</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a25b93d81626f3b63ec9c8a1516c04624" name="a25b93d81626f3b63ec9c8a1516c04624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b93d81626f3b63ec9c8a1516c04624">&#9670;&#160;</a></span>parse_mults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt; parse_mults </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs <a class="el" href="class_mult.html" title="An Expr derived class representing a multiplication operation.">Mult</a> objects from parsed multiplication expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A reference to an input stream to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="class_bool.html" title="An Expr derived class representing a basic boolean value.">Bool</a> object </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00146">146</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="a610c42a31bade3d9ac4e95f469537ba8" name="a610c42a31bade3d9ac4e95f469537ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610c42a31bade3d9ac4e95f469537ba8">&#9670;&#160;</a></span>parse_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt; parse_num </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs <a class="el" href="class_num.html" title="An Expr derived class representing a basic integer.">Num</a> objects from parsed numerical expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A reference to an input stream to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="class_num.html" title="An Expr derived class representing a basic integer.">Num</a> object</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>On invalid variable expressions </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00275">275</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="ae3f47f2a3de0566fabc8c5ea78c38c5a" name="ae3f47f2a3de0566fabc8c5ea78c38c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f47f2a3de0566fabc8c5ea78c38c5a">&#9670;&#160;</a></span>parse_paren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt; parse_paren </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles parentheses and calls new recursive chain for nested expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A reference to an input stream to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An pointer to an <a class="el" href="class_expr.html" title="An abstract, base class representing a mathematical expression.">Expr</a> object</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>On missing close parenthesis </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00429">429</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="aefd6876051de7f1849810adecbed114e" name="aefd6876051de7f1849810adecbed114e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd6876051de7f1849810adecbed114e">&#9670;&#160;</a></span>parse_var()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_expr.html">Expr</a> &gt; parse_var </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs <a class="el" href="class_var.html" title="An Expr derived class representing a string placeholder (variable)">Var</a> objects from parsed alphabetical expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A reference to an input stream to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="class_var.html" title="An Expr derived class representing a string placeholder (variable)">Var</a> object</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>On detecting malformed variables </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00335">335</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
<a id="acaf404de21e5bcf0a67503e561e7ab53" name="acaf404de21e5bcf0a67503e561e7ab53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf404de21e5bcf0a67503e561e7ab53">&#9670;&#160;</a></span>peek_keyword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string peek_keyword </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper for parse_bases that handles elements of mathematical expressions that begin with an underscore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>A reference to an input stream to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string that functions as a label for use in the calling function </dd></dl>

<p class="definition">Definition at line <a class="el" href="parse_8cpp_source.html#l00217">217</a> of file <a class="el" href="parse_8cpp_source.html">parse.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
